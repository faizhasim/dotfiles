{
  config,
  pkgs,
  lib,
  ...
}:

let
  dnsmasqConfig = ''
    # dnsmasq configuration for local development
    # Managed by nix-darwin/home-manager

    # Listen on port 53535 to avoid conflicts with mDNSResponder (port 5353) and system DNS (port 53)
    port=53535

    # Only listen on localhost to avoid conflicts with other network interfaces
    listen-address=127.0.0.1

    # Don't bind to wildcard address
    bind-interfaces

    # Don't read /etc/hosts
    no-hosts

    # Don't read /etc/resolv.conf
    no-resolv

    # Don't poll /etc/resolv.conf for changes
    no-poll

    # Never forward plain names (without a dot or domain part)
    domain-needed

    # Never forward addresses in the non-routed address spaces
    bogus-priv

    # Include all configuration files in the conf-dir
    conf-dir=${config.home.homeDirectory}/.config/dnsmasq.d/

    # Log queries for debugging (comment out for production)
    # log-queries
    # log-facility=${config.home.homeDirectory}/.config/dnsmasq.log
  '';

  direnvStdlib = ''
    # direnv stdlib function for DNS management
    # Usage: use dns <domain>
    # Example: use dns dev.seek.com.au
    # Example: use dns "*.dev.local"
    # All domains resolve to 127.0.0.1

    use_dns() {
      local domain="$1"

      if [[ -z "$domain" ]]; then
        log_error "use dns: domain argument required"
        return 1
      fi

      # Generate session ID based on current directory
      local session_id="$(pwd | shasum -a 256 | cut -d' ' -f1 | cut -c1-16)"
      local conf_file="$HOME/.config/dnsmasq.d/direnv-$session_id.conf"
      local resolver_file="/etc/resolver/$domain"

      # Idempotent: Check if entry already exists
      if [[ -f "$conf_file" ]] && grep -q "address=/$domain/127.0.0.1" "$conf_file"; then
        log_status "DNS: $domain -> 127.0.0.1 (already configured)"
        return 0
      fi

      # Create config file header if new
      if [[ ! -f "$conf_file" ]]; then
        cat > "$conf_file" <<EOF
    # Auto-generated by direnv for $(pwd)
    # Session: $session_id
    # Created: $(date)

    EOF
      fi

      # Add DNS entry (always 127.0.0.1)
      echo "address=/$domain/127.0.0.1" >> "$conf_file"

      # Create macOS resolver (idempotent)
      if [[ ! -f "$resolver_file" ]]; then
        # Try to create /etc/resolver directory (may need sudo)
        if [[ ! -d /etc/resolver ]]; then
          sudo mkdir -p /etc/resolver 2>/dev/null || {
            log_error "Failed to create /etc/resolver directory. Run: sudo mkdir -p /etc/resolver"
            return 1
          }
        fi
        echo "nameserver 127.0.0.1" | sudo tee "$resolver_file" >/dev/null
        echo "port 53535" | sudo tee -a "$resolver_file" >/dev/null
      fi

      # Reload dnsmasq
      pkill -HUP dnsmasq 2>/dev/null || true

      log_status "DNS: $domain -> 127.0.0.1"
    }
  '';

in
{
  # Create dnsmasq configuration directory and files
  xdg.configFile."dnsmasq.conf".text = dnsmasqConfig;

  # Create dnsmasq.d directory for modular configs
  xdg.configFile."dnsmasq.d/.keep".text = "# Keep directory";

  # Create direnv stdlib for use_dns function
  xdg.configFile."direnv/lib/dns.sh".text = direnvStdlib;

  # Configure launchd service for dnsmasq (macOS)
  launchd.agents.dnsmasq = {
    enable = true;
    config = {
      ProgramArguments = [
        "${pkgs.dnsmasq}/bin/dnsmasq"
        "--keep-in-foreground"
        "--conf-file=${config.home.homeDirectory}/.config/dnsmasq.conf"
      ];
      RunAtLoad = true;
      KeepAlive = true;
      StandardErrorPath = "${config.home.homeDirectory}/.local/var/log/dnsmasq.log";
      StandardOutPath = "${config.home.homeDirectory}/.local/var/log/dnsmasq.log";
    };
  };

  # Create log directory
  home.file.".local/var/log/.keep".text = "# Keep directory";
}
